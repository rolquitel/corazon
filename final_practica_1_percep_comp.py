# -*- coding: utf-8 -*-
"""Final_Practica_1_Percep_Comp.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vpZKONPzdekn2x8k3pHWX5y-Egd3ylNM
"""

from PIL import Image as im
import random as rd
import numpy as np        
import matplotlib.pyplot as plt
import os

class Una_Imagen:
    
    def __init__(self, nombre_archivo):
        # Atributo del archivo que introdujo el usuario que tiene la imagen
        self.nombre_archivo = nombre_archivo   
        
        # Atributo para cargar la imagen 
        self.imagen         = []        
        
        # Atributo para que la imagen este en escala de grises  
        self.imagen_gris    = []
        
        # Atributo para saber el número de columnas de la imagen
        self.columnas       = 0
        
        # Atributo para saber el número de renglones de la imagen
        self.renglones      = 0

        # Atributo para tener la imagen en una matriz
        self.matriz         = []
        
        # Atributo para tener la medida del kernel para la eleimnación del ruido de la imagen. Por default es el 3 X 3
        self.tamano_kernel = 3
        
        # Objeto que usa la matriz con el filtro para ser guardada
        self.imagen_guardar = []
        

    def crea_parametros(self, nombre_archivo):
        # Se carga el archivo de la imagen
        self.imagen                   = im.open(nombre_archivo)

        # Se forza a que la imagen este en escala de grises
        self.imagen_gris              = self.imagen.convert('L')
               
        # Creación de una matriz del tamaño de la imagen
        self.matriz_original          = np.array(self.imagen_gris)
        
        # Obtenemos el tamaño de la imagen en renglones y columnas
        self.renglones, self.columnas = self.matriz_original.shape
        
        self.matriz                   = self.matriz_original
                
    def guardar(self):
        # Se carga convierte la matriz en una imagen
        self.imagen_guardar           = im.fromarray(self.matriz)
        
        # Se guarda la imagen
        self.imagen_guardar.save(self.nombre_archivo[:-self.nombre_archivo.find(".")] + 
                                 "_F" + str(self.tamano_kernel) + 
                                 self.nombre_archivo[self.nombre_archivo.find("."):len(self.nombre_archivo)] )
        
        # Se imprime el nombre del archivo, agregandole un guion bajo _ más la letra F de filtro y 
        # el numero del kernel utilizado
        print("Se guardo la imagen : " + 
              self.nombre_archivo[:-self.nombre_archivo.find(".")] + 
              "_F" + str(self.tamano_kernel) + 
              self.nombre_archivo[self.nombre_archivo.find("."):len(self.nombre_archivo)] )

        
    def obten_promedio(self, posicion_x, posicion_y):
        # Definimos el movimiento del kernel
        mueve_kernel = self.tamano_kernel // 2
        
        # Igualamos el pixel inicial en Y para el kernel con la posicion inicial del pixel a promediar en Y 
        pi_k_y = posicion_y
        
        # Igualamos el pixel inicial en X para el kernel con la posicion inicial del pixel a promediar en X
        pi_k_x = posicion_x 
        
        # Restamos el valor del kernel al pixel en Y que vamos a promediar 
        pi_k_y -= mueve_kernel
        pi_k_y2 = pi_k_y
        
        # Restamos el valor del kernel al pixel en X que vamos a promediar
        pi_k_x -= mueve_kernel
        pi_k_x2 = pi_k_x
        
        # Pixeles promedio
        pi_prom = 0
        
        # Número de pixeles a promediar 
        pi_elementos = 0

        # Ciclo de lectura para buscar los pixeles que estén dentro del tamaño del kernel seleccionado
        for pi_k_y in range(pi_k_y2, posicion_y + mueve_kernel + 1, 1):
            for pi_k_x in range(pi_k_x2, posicion_x + mueve_kernel + 1, 1):               
                if ( pi_k_x >= 0 and pi_k_y >= 0 ) and ( pi_k_x < self.columnas and pi_k_y < self.renglones ):                   
                    pi_prom += self.matriz[pi_k_y][pi_k_x]
                    pi_elementos += 1

        # Promedio del pixel donde esta la posixión X y Y            
        self.matriz[posicion_y][posicion_x] = pi_prom // pi_elementos


# Función para mostrar las imágenes en pantalla
def muestra_imagen(imagen, texto, nombre_archivo):
    plt.imshow(imagen, cmap='gray')
    plt.xticks([]), plt.yticks([])
    plt.xlabel(texto + nombre_archivo)
       
    return plt.show()

# Función que graba el resultado de la matriz filtrada y calcula el nombre del archivo con el kernel seleccionado
def muestra_imagen_guardada(texto, imagen):
    nombre_archivo = ( imagen.nombre_archivo[:-imagen.nombre_archivo.find(".")] + "_F" + 
                       str(imagen.tamano_kernel) + 
                       imagen.nombre_archivo[imagen.nombre_archivo.find("."):len(imagen.nombre_archivo)] )
            
    imagen_guardada = im.open(nombre_archivo)
        
    imagen_guardada.convert('L')
    
    plt.imshow(imagen_guardada, cmap='gray')
    plt.xticks([]), plt.yticks([])
    plt.xlabel(texto + nombre_archivo)
       
    return plt.show()


# Función que pide el nombre del archivo de la imagen que se va a filtrar
def Pide_Nombre_Archivo():

    nombre_archivo = ""

    while True:
        try:
            nombre_archivo = input("Escriba por favor el nombre del archivo de la imagen : ")

        except ValueError:
            print("Debes escribir el nombre del archivo")
            continue

        if len(nombre_archivo) == 0:
            continue
        else:
            if os.path.isfile(nombre_archivo) == False:           
                print("No existe el archivo, favor de verificarlo")
                continue
            break
            
    return nombre_archivo

# Función que pide el valor del kernell para el filtro            
def Pide_Kernel():
    
    kernel_valido = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 31]

    tamano_kernel = 0

    while True:
        try:
            tamano_kernel = int(input("Escriba el tamaño del kernell, los valores validos son : " + 
                                        "[ 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 31 ]"))

        except ValueError:
            print("Debes teclear un número")
            continue

        if tamano_kernel not in kernel_valido:
            print("Debes escribir alguno de los siguientes valores : " + 
                  "[ 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 31 ]")
            continue
        else:
            break

    return tamano_kernel


def Procesa_Imagen():
    nombre_archivo = Pide_Nombre_Archivo()

    tamano_kernel = Pide_Kernel()

    # Se crea el objeto para el manenjo de la imagen
    nueva_imagen1 = Una_Imagen(nombre_archivo)

    # Se crean los parámetros del objeto de la imagen
    nueva_imagen1.crea_parametros(nombre_archivo)

    # Obtenemos el valor del kernel a utilizar
    nueva_imagen1.tamano_kernel = tamano_kernel

    # Inicializamos el primer pixel en X 
    pi_x = 0
    # Inicializamos el primer pixel en Y
    pi_y = 0

    muestra_imagen(nueva_imagen1.matriz, 
                   "Archivo original : ", 
                   nueva_imagen1.nombre_archivo)

    # Ciclos para leer los renglones y las columnas de la imagen original
    for pi_y in range(nueva_imagen1.renglones):
        for pi_x in range(nueva_imagen1.columnas):
            nueva_imagen1.obten_promedio(pi_x, pi_y)               

    nueva_imagen1.guardar()

    muestra_imagen_guardada("Archivo con filtro aplicado : ", nueva_imagen1)    

    return

